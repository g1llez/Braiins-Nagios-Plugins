#!/bin/bash

# -----------------------------------------------------------------------------
# Nagios Plugin : check_revenue_estimator_shares
#
# Estime les revenus, coûts et profits d'un site de minage Bitcoin
# en utilisant les accepted shares et la formule CRC = C × S/D
#
# Formule de revenus : CRC = C × S/D
# Où : C = Coinbase block reward (3.125 BTC), S = Shares acceptées, D = Difficulté du réseau
# Paliers Hydro-Québec : 40 kWh à 0.07708$, reste à 0.11891$ (journaliers)
#
# Retourne 9 métriques : revenus réels 5m/60m/24h, coûts réels 5m/60m/24h, profits réels 5m/60m/24h
# -----------------------------------------------------------------------------

# Variables de service
Service="REVENUE_ESTIMATOR_SHARES"

# Paramètres
if [[ $# -lt 9 ]]; then
    echo "Usage: $0 <pool_api_key> <machine_ips> <machine_user> <machine_password> <warning_threshold> <critical_threshold> <hydro_tier1_kwh> <hydro_tier1_rate> <hydro_tier2_rate>"
    echo "Example: $0 'your_pool_api_key' '192.168.1.100,192.168.1.101' 'root' 'password' 100 50 40 0.07708 0.11891"
    echo "Machine IPs can be separated by commas for multiple machines per site"
    echo "Warning/Critical thresholds are for profit margin in %"
    echo "Hydro rates are daily rates in CAD/kWh"
    exit 3
fi

POOL_API_KEY=$1
MACHINE_IPS=$2
MACHINE_USER=$3
MACHINE_PASSWORD=$4
WARNING_THRESHOLD=$5
CRITICAL_THRESHOLD=$6
HYDRO_TIER1_KWH=$7
HYDRO_TIER1_RATE=$8
HYDRO_TIER2_RATE=$9

# Conversion des IPs en tableau
IFS=',' read -ra MACHINE_IP_ARRAY <<< "$MACHINE_IPS"

# Vérification des dépendances
if ! command -v curl &> /dev/null; then
    echo "$Service UNKNOWN - curl is required but not installed"
    exit 3
fi

if ! command -v jq &> /dev/null; then
    echo "$Service UNKNOWN - jq is required but not installed"
    exit 3
fi

if ! command -v bc &> /dev/null; then
    echo "$Service UNKNOWN - bc is required but not installed"
    exit 3
fi

# Fonction pour récupérer les accepted shares depuis l'API Braiins
get_accepted_shares() {
    local api_key=$1
    local api_url="https://pool.braiins.com/accounts/profile/json/btc/"
    
    local response=$(curl -s -H "Pool-Auth-Token: $api_key" "$api_url")
    
    if [[ $? -ne 0 ]]; then
        echo "ERROR"
        return 1
    fi
    
    if [[ $response == *"error"* ]] || [[ $response == *"Error"* ]]; then
        echo "ERROR"
        return 1
    fi
    
    # Extraction des valeurs d'accepted shares
    local shares_5m=$(echo "$response" | jq -r '.btc.accepted_shares_5m // .btc.shares_5m // empty' 2>/dev/null)
    local shares_60m=$(echo "$response" | jq -r '.btc.accepted_shares_60m // .btc.shares_60m // empty' 2>/dev/null)
    local shares_24h=$(echo "$response" | jq -r '.btc.accepted_shares_24h // .btc.shares_24h // empty' 2>/dev/null)
    
    if [[ $shares_5m == "null" ]] || [[ -z $shares_5m ]]; then
        echo "ERROR"
        return 1
    fi
    
    echo "$shares_5m:$shares_60m:$shares_24h"
}

# Fonction pour récupérer la difficulté du réseau Bitcoin depuis l'API publique
get_network_data() {
    # Utilisation de l'API publique de Blockchain.info pour récupérer la difficulté actuelle
    local api_url="https://blockchain.info/q/getdifficulty"
    
    local response=$(curl -s --max-time 10 "$api_url")
    
    if [[ $? -ne 0 ]]; then
        echo "ERROR"
        return 1
    fi
    
    # Vérification que la réponse n'est pas vide
    if [[ -z "$response" ]]; then
        echo "ERROR"
        return 1
    fi
    
    # Gestion de la notation scientifique (ex: 1.29435235580345E14)
    local difficulty=$(echo "$response" | sed 's/E/*10^/g' | bc -l 2>/dev/null)
    
    if [[ -z "$difficulty" ]] || [[ "$difficulty" = "0" ]]; then
        echo "ERROR"
        return 1
    fi
    
    echo "$difficulty"
}

# Fonction pour récupérer la coinbase reward (fixe après le halving d'avril 2024)
get_coinbase_reward() {
    # Coinbase block reward actuellement 3.125 BTC après le halving d'avril 2024
    echo "3.125"
}

# Fonction pour récupérer le prix Bitcoin depuis Bitcoin Common API
get_bitcoin_price() {
    # Récupération du prix en CAD depuis notre API centralisée (avec cache intégré)
    local response=$(curl -s --max-time 10 "http://api.sarius.ca/api/v1/bitcoin/price")
    
    if [[ $? -ne 0 ]]; then
        echo "ERROR"
        return 1
    fi
    
    # Vérification de la validité de la réponse
    if [[ -z "$response" ]] || [[ "$response" == "null" ]]; then
        echo "ERROR"
        return 1
    fi
    
    # Extraction du prix CAD
    local price_cad=$(echo "$response" | jq -r '.price_cad // empty' 2>/dev/null)
    
    # Validation du prix
    if [[ -z "$price_cad" ]] || [[ "$price_cad" == "null" ]] || [[ "$price_cad" == "0" ]]; then
        echo "ERROR"
        return 1
    fi
    
    # Vérification que le prix est réaliste (entre 1000$ et 1000000$ CAD)
    if (( $(echo "$price_cad < 1000" | bc -l) )) || (( $(echo "$price_cad > 1000000" | bc -l) )); then
        echo "ERROR"
        return 1
    fi
    
    echo "$price_cad"
}

# Fonction pour récupérer la consommation électrique
get_power_consumption() {
    local machine_ip=$1
    local machine_user=$2
    local machine_password=$3
    
    # Utilise grpcurl pour récupérer la consommation électrique
    local auth=$(grpcurl -plaintext -v -d '{"username": "'$machine_user'", "password": "'$machine_password'"}' $machine_ip:50051 'braiins.bos.v1.AuthenticationService/Login' 2>/dev/null)
    
    if [[ $? -ne 0 ]]; then
        echo "ERROR"
        return 1
    fi
    
    local token=$(echo -e "$auth" | grep 'authorization:' | awk '{print $2}')
    
    if [[ -z "$token" ]]; then
        echo "ERROR"
        return 1
    fi
    
    local info=$(grpcurl -plaintext -H 'authorization:'$token'' $machine_ip:50051 'braiins.bos.v1.PerformanceService/GetTunerState' 2>&1)
    
    # Vérifier si BOSminer n'est pas en cours d'exécution
    if echo "$info" | grep -q "BOSminer is not running"; then
        echo "BOSMINER_STOPPED"
        return 1
    fi
    
    # Vérifier si la requête a échoué
    if [[ $? -ne 0 ]]; then
        echo "ERROR"
        return 1
    fi
    
    local watt=$(echo $info | jq '.powerTargetModeState.profile.estimatedPowerConsumption.watt' 2>/dev/null | tr -d '"')
    
    if [[ "$watt" == "null" ]] || [[ -z "$watt" ]]; then
        echo "ERROR"
        return 1
    fi
    
    echo "$watt"
}

# Fonction pour calculer le coût électrique par période
calculate_period_electric_cost() {
    local power_watts=$1
    local period_minutes=$2
    
    # Conversion en kWh pour la période
    local period_kwh=$(echo "scale=6; $power_watts * $period_minutes / 60 / 1000" | bc -l)
    
    # Pour les paliers Hydro-Québec, on calcule proportionnellement
    # Note: Les paliers sont journaliers, donc on applique la proportion
    local daily_kwh=$(echo "scale=3; $power_watts * 24 / 1000" | bc -l)
    local period_ratio=$(echo "scale=8; $period_minutes / 1440" | bc -l)
    
    local cost=0
    
    if (( $(echo "$daily_kwh <= $HYDRO_TIER1_KWH" | bc -l) )); then
        # Tout au premier palier
        cost=$(echo "scale=4; $period_kwh * $HYDRO_TIER1_RATE" | bc -l)
    else
        # Calcul proportionnel des paliers
        local daily_tier1_cost=$(echo "scale=2; $HYDRO_TIER1_KWH * $HYDRO_TIER1_RATE" | bc -l)
        local daily_tier2_kwh=$(echo "scale=3; $daily_kwh - $HYDRO_TIER1_KWH" | bc -l)
        local daily_tier2_cost=$(echo "scale=2; $daily_tier2_kwh * $HYDRO_TIER2_RATE" | bc -l)
        local daily_total_cost=$(echo "scale=2; $daily_tier1_cost + $daily_tier2_cost" | bc -l)
        
        # Coût proportionnel à la période
        cost=$(echo "scale=4; $daily_total_cost * $period_ratio" | bc -l)
    fi
    
    echo "$cost"
}

# Fonction pour calculer les revenus par période basés sur la formule CRC = C × S/D
# Les accepted shares sont déjà proportionnels au temps, pas besoin de ratio temporel
calculate_period_revenue_shares() {
    local accepted_shares=$1
    local coinbase_reward=$2
    local network_difficulty=$3
    local btc_price_cad=$4
    local period_minutes=$5
    
    # Formule CRC = C × S/D
    # Où :
    # C = Coinbase block reward (3.125 BTC après le halving d'avril 2024)
    # S = Vos shares acceptées (déjà proportionnelles au temps)
    # D = Difficulté du réseau
    
    # Calcul du BTC gagné pour la période selon la formule CRC
    # Pas de ratio temporel car les shares sont déjà proportionnels
    local period_btc=$(echo "scale=12; $coinbase_reward * $accepted_shares / $network_difficulty" | bc -l)
    
    # Calcul du revenu en CAD
    local period_revenue_cad=$(echo "scale=12; $period_btc * $btc_price_cad" | bc -l)
    
    # Debug: afficher les étapes du calcul
    echo "DEBUG: Période ${period_minutes}m - Shares: $accepted_shares, BTC: $period_btc, CAD: $period_revenue_cad" >&2
    
    echo "$period_revenue_cad"
}

# Récupération des données
echo "Récupération des données..." >&2

# Accepted Shares (5m, 60m, 24h)
shares_data=$(get_accepted_shares "$POOL_API_KEY")
if [[ $shares_data == "ERROR" ]]; then
    echo "$Service UNKNOWN - Impossible de récupérer les accepted shares"
    exit 3
fi

shares_5m=$(echo "$shares_data" | cut -d: -f1)
shares_60m=$(echo "$shares_data" | cut -d: -f2)
shares_24h=$(echo "$shares_data" | cut -d: -f3)

# Debug: afficher les valeurs des shares
echo "DEBUG: Shares 5m: $shares_5m, 60m: $shares_60m, 24h: $shares_24h" >&2

# Coinbase reward (fixe)
coinbase_reward=$(get_coinbase_reward)
echo "DEBUG: Coinbase reward: $coinbase_reward BTC" >&2

# Difficulté du réseau
network_difficulty=$(get_network_data)
if [[ $network_difficulty == "ERROR" ]]; then
    echo "$Service UNKNOWN - Impossible de récupérer la difficulté du réseau"
    exit 3
fi
echo "DEBUG: Network difficulty: $network_difficulty" >&2

# Prix Bitcoin (CAD)
btc_price_cad=$(get_bitcoin_price)
if [[ $btc_price_cad == "ERROR" ]]; then
    echo "$Service UNKNOWN - Impossible de récupérer le prix Bitcoin"
    exit 3
fi

# Consommation électrique totale (Watts) pour toutes les machines
total_power_watts=0
active_machines=0
error_machines=0
machine_details=""
error_details=""

for machine_ip in "${MACHINE_IP_ARRAY[@]}"; do
    echo "Récupération de la consommation pour $machine_ip..." >&2
    power_watts=$(get_power_consumption "$machine_ip" "$MACHINE_USER" "$MACHINE_PASSWORD")
    
    if [[ $power_watts == "ERROR" ]]; then
        error_machines=$((error_machines + 1))
        error_details+="$machine_ip:ERROR "
        echo "Machine $machine_ip: ERREUR de connexion" >&2
        continue
    elif [[ $power_watts == "BOSMINER_STOPPED" ]]; then
        echo "Machine $machine_ip: BOSminer arrêté" >&2
        machine_details+="$machine_ip:STOPPED "
        continue
    else
        total_power_watts=$(echo "scale=2; $total_power_watts + $power_watts" | bc -l)
        active_machines=$((active_machines + 1))
        machine_details+="$machine_ip:${power_watts}W "
        echo "Machine $machine_ip: ${power_watts}W" >&2
    fi
done

# Si TOUTES les machines ont des erreurs, on retourne UNKNOWN
if [[ $active_machines -eq 0 ]] && [[ $error_machines -gt 0 ]]; then
    echo "$Service UNKNOWN - Aucune machine accessible: $error_details"
    exit 3
elif [[ $active_machines -eq 0 ]]; then
    echo "$Service UNKNOWN - Aucune machine active trouvée"
    exit 3
fi

echo "Total: ${active_machines} machines actives, ${total_power_watts}W" >&2
if [[ $error_machines -gt 0 ]]; then
    echo "Attention: ${error_machines} machines en erreur: $error_details" >&2
fi

# Calculs
echo "Calculs en cours..." >&2

# Revenus réels (CAD) pour chaque période basés sur la formule CRC = C × S/D
revenue_5m=$(calculate_period_revenue_shares "$shares_5m" "$coinbase_reward" "$network_difficulty" "$btc_price_cad" 5)
revenue_60m=$(calculate_period_revenue_shares "$shares_60m" "$coinbase_reward" "$network_difficulty" "$btc_price_cad" 60)
revenue_24h=$(calculate_period_revenue_shares "$shares_24h" "$coinbase_reward" "$network_difficulty" "$btc_price_cad" 1440)

# Coûts électriques réels (CAD) pour chaque période
cost_5m=$(calculate_period_electric_cost "$total_power_watts" 5)
cost_60m=$(calculate_period_electric_cost "$total_power_watts" 60)
cost_24h=$(calculate_period_electric_cost "$total_power_watts" 1440)

# Profits réels (CAD) pour chaque période
profit_5m=$(echo "scale=4; $revenue_5m - $cost_5m" | bc -l)
profit_60m=$(echo "scale=4; $revenue_60m - $cost_60m" | bc -l)
profit_24h=$(echo "scale=4; $revenue_24h - $cost_24h" | bc -l)

# Calcul du pourcentage de profit (basé sur 24h pour la comparaison des seuils)
profit_percentage=0
if (( $(echo "$revenue_24h > 0" | bc -l) )); then
    profit_percentage=$(echo "scale=1; $profit_24h / $revenue_24h * 100" | bc -l)
fi

# Détermination du statut
status="OK"
statusCode=0

if (( $(echo "$profit_percentage <= $CRITICAL_THRESHOLD" | bc -l) )); then
    status="CRITICAL"
    statusCode=2
elif (( $(echo "$profit_percentage <= $WARNING_THRESHOLD" | bc -l) )); then
    status="WARNING"
    statusCode=1
fi

# Formatage des nombres pour l'affichage
format_currency() {
    local value=$1
    printf "%.2f" "$value"
}

# Construction du message
if [[ $error_machines -gt 0 ]]; then
    msg="$Service $status - Profit 5m: $(format_currency $profit_5m)$ CAD, 60m: $(format_currency $profit_60m)$ CAD, 24h: $(format_currency $profit_24h)$ CAD (${profit_percentage}% sur 24h) [${active_machines}/${#MACHINE_IP_ARRAY[@]} machines: ${total_power_watts}W, ${error_machines} errors] | "
else
    msg="$Service $status - Profit 5m: $(format_currency $profit_5m)$ CAD, 60m: $(format_currency $profit_60m)$ CAD, 24h: $(format_currency $profit_24h)$ CAD (${profit_percentage}% sur 24h) [${active_machines} machines: ${total_power_watts}W] | "
fi
msg+="revenue_5m=$(format_currency $revenue_5m) revenue_60m=$(format_currency $revenue_60m) revenue_24h=$(format_currency $revenue_24h) "
msg+="cost_5m=$(format_currency $cost_5m) cost_60m=$(format_currency $cost_60m) cost_24h=$(format_currency $cost_24h) "
msg+="profit_5m=$(format_currency $profit_5m) profit_60m=$(format_currency $profit_60m) profit_24h=$(format_currency $profit_24h) "
msg+="profit_pct_24h=${profit_percentage} active_machines=${active_machines} total_power=${total_power_watts} error_machines=${error_machines} "
msg+="shares_5m=${shares_5m} shares_60m=${shares_60m} shares_24h=${shares_24h}"

echo "$msg"
exit $statusCode
